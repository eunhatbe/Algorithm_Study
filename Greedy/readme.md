## 그리디 알고리즘
그리디 알고리즘은 탐욕 알고리즘으로도 불린다. 이름에서 추측할 수 있듯이 단순 무식하게, 탐욕적으로 문제를 해결하는 알고리즘이다. 탐욕적이라는 말은 **현재 상황에서 지금 당장 좋은 것만 고르는 방법**이다. 그리디 알고리즘은 매 순간 가장 좋아 보이는 것을 선택하며, 현재의 선택이 나중에 미칠 영향에 대해서는 고려하지 않는다.

그리디는 기본적으로 알고리즘의 사용 방법을 정확히 알고 있지 않아도 해결할 수 있을 가능성이 높은 문제 유형이다. 예를 들어 데이터를 빠르게 정렬해야 하는 문제는 정렬의 사용 방법을 알고 있어야 해결 가능하다. 또한 최단 경로를 빠르게 찾아야 하는 문제는 플로이드 워셜 혹은 다익스트라 알고리즘과 같은 특정 알고리즘을 알고 있어야 한다. 엄밀히 따지면 다익스트라 알고리즘은 그리디 유형으로 분리되므로 다익스트라 같은 특수한 케이스가 아닌 경우엔 알고리즘의 암기가 필요없다. 또한 그리디 알고리즘은 굉장히 다양한 유형이 있으므로 많은 유형을 접해봐야한다.

그리디 알고리즘은 기준에 따라 좋은 것을 선택하는 알고리즘이므로 문제에서  **'가장 큰 순서대로'** 혹은 **'가장 작은 순서대로'** 와 같은 기준을 알게 모르게 제시해준다. 대체로 이러한 기준은 정렬 알고리즘을 사용해서 만족시킬 수 있으므로 그리디 알고리즘은 보통 정렬 알고리즘과 짝을 이뤄서 문제로 제시된다.
그리디 알고리즘 분류에서 유명한 거스름돈 문제를 살펴보자


### 거스름돈 문제
당신은 음식점의 계산을 도와주는 종업원이다. 카운터에는 거스름돈으로 사용할 500원,100원,50원,10원짜리 동전이 **무한히** 존재한다고 가정한다. 손님에게 거슬러 줘야 할 돈 N원일 떄 거슬러 줘야 할 동전의 최소 개수를 구하라.(단, 거슬러 줘야 할 돈 N은 항상 10의 배수이다.)

### 거스름돈 문제 해법
이 문제는 그리디 유형에서 가장 대표적인 문제로 간단한 기준으로 해결할 수 있다. 바로 **'가장 큰 화폐 단위부터 돈을 거슬러 주는것'**이다. n원을 거슬러 줘야할 떄 가장 먼저 가장 큰 화폐단위인 500원으로 거슬러 줄 수 있을 만큼 거슬러 준다. 그다음 100원, 50원, 10원짜리 순으로 차례대로 거슬러 줄 수 있을 만큼 거슬러 주면 최소의 동전 개수로 모두 거슬러 줄 수 있다.

```py
n = 1560
count = 0

# 화폐를 가장 큰 순서로 정렬
coins = [500, 100, 50, 10]  

for coin in coins:
    count += n // coin      # 해당 화폐로 거슬러 줄 수 있는 동전의 개수 카운트
    n %= coin               # 거슬러 줘야하는 돈 % 현재 화폐 의 나머지 ex 1560 % 500 = 60 (거슬러줘야 할 돈 60)

print(count)
```

그리디 알고리즘은 모든 알고리즘 문제에 적용할 수 있는 것은 아니다. 대부분의 문제는 그리디 알고리즘을 이용했을 때 최적의 해를 찾을 수 없을 가능성이 있다. 하지만 위에 거스름돈 문제에서 선택한 기준 가장 큰 화폐 단위부터 돈을 거슬러 주는 것과 같이 탐욕적으로 문제에 접근 했을 떄 정확한 답을 찾을 수 있다는 보장이 있을 떄는 매우 효과적이고 직관적이다.

그리디 알고리즘으로 문제의 해법을 찾았을 떄는 그 해법이 정당한지 검토해야 한다.
위 문제를 그리디로 해결할 수 있는 이유는 **가지고 있는 동전 중에서 큰 단위가 항상 작은 단위의 배수이므로 작은 단위의 동전들을 종합해 다른 해가 나올 수 없기 떄문이다.**

만약 위 문제에서 화폐 단위가 500원, 400원, 100원이고 거슬러 줘야할 돈은 800원이라 가정해보자.
직관적으로 400원짜리 2개를 거슬러 주는것이 가장 적은 개수의 동전을 거슬러 줄 수 있다. 하지만 위 그리디 문제 해법대로 라면
큰 화폐 순서대로 500원 1개 100원 3개가 나온다. 이 문제에서는 큰 단위가 작은 단위의 배구 형태이므로, '가장 큰 단위의 화폐부터 가장 작은 단위의 화폐까지 순서대로 확인하여 거슬러 주는 작업만을 수행하면 된다.' 라는 아이디어는 정당하다.
대부분의 그리디 알고리즘은 문제에서는 이처럼 문제 풀이를 위한 최소한의 아이디어를 떠올리고 이것이 정당한지 검토할 수 있어야 해답을 찾을 수 있다.

실제로 거스름돈 문제에서 화폐의 단위가 서로 배수 형태가 아닌, 무작위로 주어진 경우에는 그리디 알고리즘으로는 해결할 수 없다.
화폐의 단위가 무작위로 주어진 문제는 [다이나믹 프로그래밍](https://github.com/eunhatbe/Algorithm_Study/tree/main/dynamic)을 통해서 해결할 수 있다.


### 큰 수의 법칙
큰 수의 법칙은 다양한 수로 이루어진 배열이 있을 때 주어진 수들을 M번 더하여 가장 큰 수를 만드는 법칙이다. 단, 배열의 특정한 인덱스에 해당하는 수가 연속해서 K번을 초과하여 더해질 수 없는 것이 이 법칙의 특징이다.
예를 들어 순서대로 [2, 4, 5, 4, 6]으로 이루어진 배열이 있을 떄 M이 8이고 K가 3이라고 가정하자, 이 경우 특정한 인덱스의 수가 연속해서 세 번까지만 더해질 수 있으므로 큰 수의 법칙에 따른 결과는 [6 + 6 + 6 + 5 + 6 + 6 + 6 + 5]인 46이 된다.
단, 서로 다른 인덱스에 해당하는 수가 같은 경우에도 서로 다른 것으로 간주한다. 예를 들어 순서대로 [3, 4, 3, 4, 3]으로 이루어진 배열이 있을 때 M이 7이고 K가 2라고 가정하자, 이 경우 두 번쨰 원소에 해당하는 4와 네 번째 원소에 해당하는 4를 번갈아 두 번씩 더하는 것이 가능하다. 결과적으로 [4 + 4 + 4 + 4 + 4 + 4 + 4]인 28이 나온다.

배열의 크기 N, 숫자가 더해지는 횟수 M, 그리고 K가 주어질 떄 위 큰 수의 법칙에 따른 결과를 출력하시오

```python

n, m, k = map(int, input().split())
data = list(map(int, input().split()))

data.sort()
first = data[n - 1]     # 가장 큰 수
second = data[n - 2]    # 두 번째 큰 수

result = 0

while True:
    for i in range(k):      # 가장 큰 수를 k번 더하기
        if m == 0:          # m 이 0이라면 반복문 탈출
            break
        result += first
        m -= 1

    if m == 0:
        break

    result += second
    m -= 1


print(result)
```
위 해답은 M이 10000 이하이므로 위 방식으로도 문제를 해결할 수 있지만, M의 크기가 100억 이상처럼 커진다면 위 방식으로는 시간 초과 판정을 받을 것이다.
